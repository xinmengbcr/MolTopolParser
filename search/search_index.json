{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"MolTopolParser <p>MolTopolParser, abbreviated from Molecular Topology Parser, is a lightweight, open-source Python package designed for accessing, validating, and processing files or data from various molecular simulation and modeling software. It simplifies interfacing between different simulation software and is pivotal in building computational pipelines for molecular simulations.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#requirements","title":"Requirements","text":"<ul> <li> <p>Python 3.6 or newer</p> </li> <li> <p>pip package manager</p> </li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>To install MolTopolParser, run the following command:</p> <pre><code>pip install moltopolparser\n</code></pre>"},{"location":"#dependencies","title":"Dependencies","text":"<p>MolTopolParser requires the following Python packages:</p> <ul> <li>pydantic</li> <li>numpy</li> </ul> <p>These dependencies are automatically installed during the MolTopolParser installation process.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> <p>Modular Design: Structured around specific file formats from various simulation software, enhancing maintainability and scalability.</p> </li> <li> <p>Pydantic Dataclasses: Ensures robust data validation and type checking across the package.</p> </li> <li> <p>Parsing as Class Methods: Facilitates easy access to and manipulation of simulation files through well-defined class methods.</p> </li> <li> <p>Exposed Modules and Dataclasses: Enables advanced users to extend functionality or integrate with other tools.</p> </li> </ul>"},{"location":"#when-to-use","title":"When To Use","text":"<p>MolTopolParser is designed for developers to manage hierarchical data structures commonly used in molecular simulations. It provides a robust foundation for building advanced simulation tools and pipelines.</p> <p>Yes</p> <ul> <li>Accessing and manipulating simulation files beyond mere coordinate data.</li> <li>Interfacing between different molecular simulation software.</li> <li>Building and managing computational pipelines.</li> </ul> <p>No</p> <ul> <li>Simple parsing of structural data.</li> <li>Basic analysis of simulation outputs. (Consider using Biopython , MDAanalysis etc.)</li> </ul>"},{"location":"#usage-examples","title":"Usage Examples","text":""},{"location":"#parsing-gromacs-files","title":"Parsing Gromacs Files","text":"<pre><code>import moltopolparser as mtp\n\n# Validate base data directly\natom_data = {\n    \"id\": 10, \"atom_type\": \"C\", \"resnr\": 100,\n    \"residu\": \"UREA\", \"atom\": \"C1\", \"cgnr\": 1, \"charge\": -0.683,\n}\natom = mtp.gmx.MolTopAtom(**atom_data)\nprint(atom.charge)\n\n# Parsing a single .gro file\ngro_file = '../tests/data/gmx/two_water.gro'\ngro = mtp.gmx.GroFile.parser(gro_file)\nprint(gro.box_size)\n\n# Parsing and accessing a top file\ntop_file = '../tests/data/gmx/membrane-martini-charmmgui/system.top'\nsys_top = mtp.gmx.Topology.parser(top_file)\nprint(sys_top.system)\n\nsys_top.pull_forcefield()\nprint(sys_top.forcefield.atomtypes[0])  # Output: name='P5' at_num=None mass=72.0 charge=0.0 ptype='A' sigma=0.0 epsilon=0.0\n\nsys_top.pull_molecule_topologies()\nprint(sys_top.molecule_topologies[0])\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>We encourage contributions from the community! Whether you are fixing bugs, proposing new features, or improving the documentation, your help is welcome.</p> <ul> <li> <p>For Beginners  Submit issue requests for bugs or feature suggestions.</p> </li> <li> <p>For Developers Read the Concepts and follow our Developer's Guidence to understand how to set up your environment and contribute code.</p> </li> </ul>"},{"location":"#versioning-and-changelog","title":"Versioning and Changelog","text":"<p>For details on the latest changes and version history, please refer to the full Change Log on GitHub.</p>"},{"location":"#license","title":"License","text":"<p>MolTopolParser is released under the Apache License. See the LICENSE file for more details.</p>"},{"location":"concepts/","title":"How does it work - Concepts","text":"<p>Understanding the underlying principles and architecture of MolTopolParser is essential for both using and contributing to the package. This section explains the types of files involved in molecular simulation projects, the design principles of MolTopolParser, and the data abstraction model it uses.</p> <p>In molecular dynamics simulations, several types of files are typically used, each serving a specific purpose:</p> <ul> <li> <p>Coordinate Files: Store the initial atomic or molecular coordinates that define the structure of the system.</p> </li> <li> <p>Topology Files: Contain detailed system information, including the types of particles and their interactions.</p> </li> <li> <p>Force Field Files: Define the forces applied to the particles in the system, specifying parameters such as bond lengths, angles, and torsional angles. These files are critical for setting up and running molecular simulations accurately.</p> </li> </ul> <p></p>"},{"location":"concepts/#components-and-composition","title":"Components and Composition","text":"<p>An efficient way to think of all the files is as a composition of blocks of well-defined information. Similar to the concept in React, a meaningful block can be defined into a component.  Then, a developer just needs to classify and organize these components.</p> <p>MolTopolParser is designed with a composition focus, providing an easy way to organize, access,  validate, and manipulate these blocks of information.</p>"},{"location":"concepts/#three-order-component-model-toc","title":"Three-Order Component Model (TOC)","text":"<p>The TOC model simplifies data handling by categorizing data into three hierarchical levels:</p> <ul> <li>Level 1: Base Classes - These classes map directly to individual data entries, such as a single atom or bond. They provide immediate validation and data encapsulation.</li> <li>Level 2: Aggregation Classes - These classes manage groups of base components, such as all atoms in a molecule or all molecules in a system, facilitating operations on collections of components.</li> <li>Level 3: Summary Classes - At the highest level, these classes provide a summary or an overview of entire datasets or simulation setups, integrating multiple aggregation classes.</li> </ul>"},{"location":"concepts/#component-behaviour","title":"Component Behaviour","text":"<p>MolTopolParser operates on a clear data flow principle:</p> <ul> <li> <p>Declaration and Organization: Data structures are defined and organized from the top down, starting with the most comprehensive views</p> </li> <li> <p>Acquisition and Validation: Data is parsed and validated from the bottom up, ensuring integrity at each step of the data structure</p> </li> </ul>"},{"location":"concepts/#parsing-mechanism","title":"Parsing Mechanism","text":"<p>When parsing data:</p> <ul> <li> <p>Shallow Parsing: Top-level components perform shallow parsing to recognize data structures without delving into details.</p> </li> <li> <p>Deep Parsing: Detailed parsing tasks are delegated to lower levels, allowing higher-level components to remain abstract and focused on structure. This method of delegation ensures efficiency and maintains clarity in data handling, avoiding redundancy and confusion in complex datasets.</p> </li> </ul>"},{"location":"concepts/#further-reading","title":"Further Reading","text":"<p>To understand how these concepts are implemented in MolTopolParser, please refer to the Developer's Guidence. This guide includes detailed examples and explanations of each component level and offers insight into extending MolTopolParser's capabilities.</p>"},{"location":"developer/","title":"Developer's Guide","text":"<p>Welcome to the MolTopolParser developer's guide.  This guide provides all the necessary information for setting up your development environment, understanding the codebase, and contributing effectively to the project.</p>"},{"location":"developer/#environment-setup","title":"Environment Setup","text":""},{"location":"developer/#clone-the-repository","title":"Clone the Repository","text":"<p>Start by cloning the MolTopolParser repository to your local machine:</p> <pre><code>git clone https://github.com/your-username/MolTopolParser.git\ncd MolTopolParser\n</code></pre>"},{"location":"developer/#create-a-virtual-environment","title":"Create a Virtual Environment","text":"<p>It's recommended to create a virtual environment for development to manage dependencies cleanly: <pre><code>python -m venv .venv\nsource .venv/bin/activate\n</code></pre></p>"},{"location":"developer/#install-dependencies","title":"Install Dependencies","text":"<p>Install all required dependencies using pip: <pre><code>pip install --upgrade pip\npip install -r requirements.txt\npip install -e .\n</code></pre></p>"},{"location":"developer/#run-tests","title":"Run Tests","text":"<p>Ensure that all tests pass to verify your setup: <pre><code>pytest tests -v -s\n</code></pre></p>"},{"location":"developer/#developing-a-new-module","title":"Developing a New Module","text":"<p>If you are adding a new module to support a different simulation software, here's how to get started:</p>"},{"location":"developer/#add-a-module-file","title":"Add a module file","text":"<ol> <li>Create a new file under the <code>moltopolparser</code> directory for your module, e.g., <code>xxx.py</code>.</li> <li>Register the new module in the <code>__init__.py</code> file:</li> </ol> <pre><code>from . import xxx\n__all__ = ['gmx', 'xxx']\n</code></pre>"},{"location":"developer/#define-data-classes","title":"Define Data Classes","text":"<p>Organize your module using the Three-Order Component (TOC) model:</p> <ol> <li>Level 1 Base Data Classes - Define data classes for the smallest data units.</li> <li>Level 2 Aggregation Classes - Group base classes into meaningful sections.</li> <li>Level 3 Summary Classes - Organize and manage entire file contents or complex data structures.</li> </ol>"},{"location":"developer/#implement-parsing-functions","title":"Implement Parsing Functions","text":"<p>Add class methods for parsing data, validating, and possibly manipulating or transforming data.</p>"},{"location":"developer/#testing-your-module","title":"Testing Your Module","text":"<p>Create a testing file in the <code>tests</code> directory:</p> <ol> <li>Structure: Place your test file, e.g., <code>test_xxx.py</code>.</li> <li>Data Files: Store necessary data files under <code>tests/data/xxx/</code> for use in tests.</li> </ol>"},{"location":"developer/#example-code-block","title":"Example Code Block","text":"<p>Here\u2019s a simplified structure of what your module file might look like:</p> <pre><code># Header and Imports\n\"\"\"\nModule to parse and manage data from Software XXX\n\"\"\"\nimport necessary_libraries # (1)\n\n# Base dataclasses\nclass BaseClass:\n    pass\n\n# Aggregation dataclasses\nclass AggregateClass:\n    pass\n\n# Summary dataclasses\nclass SummaryClass:\n    pass\n\n# Additional helper functions if needed\n</code></pre> <ol> <li>If new packages need to be installed, please also update the <code>setup.py</code> and <code>requirements.txt</code> files </li> </ol>"},{"location":"developer/#understanding-data-access-and-manipulation","title":"Understanding Data Access and Manipulation","text":"<p>MolTopolParser simplifies the process of working with molecular simulation files by providing structured data access  through its class hierarchy. The process typically begins with the initialization of a top-level data class,  which acts as a gateway to all underlying data associated with a simulation.</p>"},{"location":"developer/#top-level-dataclass-initialization","title":"Top-Level Dataclass Initialization","text":"<p>When you initialize the top-level dataclass, it constructs an instance that encapsulates all the necessary information of the system and its related contents from the target files.  This encapsulation allows for a structured and organized approach to accessing and manipulating the data:</p> <pre><code># Example of initializing a top-level dataclass\nsystem_topology = SystemTopology(parser=\"path/to/topology_file.top\")\n</code></pre>"},{"location":"developer/#accessing-data","title":"Accessing Data","text":"<p>Once the top-level class is initialized, specific data can be accessed by invoking corresponding  methods defined within the class. These methods typically follow the naming convention <code>pull_*</code> to indicate that they  retrieve specific types of data or perform certain operations to organize and validate data: <pre><code># Example of accessing data using a method\nsystem_topology.pull_forcefield()\nsystem_topology.pull_molecules()\nforcefield_data = system_topology.forcefield\nmolecules = system_topology.molecules\n</code></pre></p>"},{"location":"developer/#illustration","title":"Illustration","text":"<p>The following figure demonstrates the Initialization and Access Procoesses based on a toy module file. </p> <p></p> <p>Here\u2019s the toy module file:</p> <p>Five Sections in a toye module file</p> Header and ImportsLevel 1: Base dataclassesLevel 2:  Aggregation dataclassesLevel 3: Summary dataclasse(s)Helper functions <pre><code>#####  Header information \n\"\"\"\nDescription\n\"\"\"\n#####  Import replying modules\nimport ... \n</code></pre> <pre><code>class Base1(BaseModel):\n    \"\"\"\n    Description\n    \"\"\"\n    ### attributes, e.g. \n    field_1: int = Field(..., description=\"x\")\n    ### parse templates\n    model_config = ConfigDict(\n        json_schema_extra={\n            ...\n        }\n    )\n    #### classmethod for parsing \n    @classmethod\n    def parser(cls, content: List[str]) -&gt; Union[\"Base1\", List[\"Base1\"]]:\n        ...\nclass Base2 ...\n</code></pre> <pre><code>class Aggregation1(BaseModel):\n    \"\"\"\n    Description\n    \"\"\"\n    ### attributes of BaseData e.g. \n    field_1: List[Base1] = Field(..., description=\"x\")\n    field_2: List[Base2] = Field(..., description=\"x\")\n    ### parse templates\n    model_config = ConfigDict(\n        json_schema_extra={\n            ...\n        }\n    )\n    ### classmethod parsing\n    @classmethod\n    def parser(cls, content_lines: Optional[List[str]] = None, content_files: Optional[List[str]] = None):\n        \"\"\"\n        Parse the aggregation data from the content passed when it is called\n        \"\"\"\n        data1_list = Base1.parser(content_lines) # &lt;-- call the exact parsing classmethod at Base level \n        data2_list = Base2.parser(content_lines)\n        data = {\n            field_1:data1_list\n            field_2:data2_list\n        }\n        return Aggregation1(**data) \n</code></pre> <pre><code>class Summary(BaseModel):\n    \"\"\"\n    Description\n    \"\"\"\n    ### manditory attributes to initite  \n    field_1: str = Field(..., description=\"x\")\n    ### attritues composed of AggregationData to be parsed e.g. \n    field_2: Optional[List[Aggregation1]] = Field(None, description=\"x\")\n    ### attritue, collection of content to be passed when delegate the parsing tasks\n    ### could be lines of data, or route of flles \n    pass_content: Optional[List[str]] = Field( None,description=\"x\",)\n\n    ### parse templates\n    model_config = ConfigDict(\n        json_schema_extra={\n            ...\n        }\n    )\n    ### classmethod for shallow parsing,\n    ### obtain the  manditory attributes \n    ### and return a cls instance\n    @classmethod\n    def parser(cls, filename: str):\n        ...\n\n    ### instance method to delegate parsing tasks \n    def pull_field2(self)\n        ### call aggregation level classmethod\n        self.field_2 = Aggregation1.parser(self.pass_content)        \n</code></pre> <pre><code>### Helper functions e.g. \n### deployed to filter out commnets in content, \n### to locate range of data need to be passed. \n</code></pre>"},{"location":"developer/#practice-with-gmxpy","title":"Practice with gmx.py","text":"<p>Module <code>gmx.py</code> contains all the detailed implemenations.  Via reading the code, all the concepts should be clarified. </p> <p>It is also recommended to copy the <code>gmx.py</code> to start a new module. </p>"},{"location":"developer/#submitting-contributions","title":"Submitting Contributions","text":""},{"location":"developer/#pull-requests","title":"Pull Requests","text":"<ol> <li>Fork the repository - Make a copy of the project on your GitHub account.</li> <li>Make your changes - Work on your fork and make the changes you propose.</li> <li>Submit a pull request - Open a pull request from your fork back to the main repository.</li> </ol>"},{"location":"developer/#code-style-and-review","title":"Code Style and Review","text":"<p>Follow PEP 8 guidelines for Python code. Ensure your code is clean and well-documented. All contributions will undergo a review process by core maintainers.</p>"},{"location":"developer/#attention","title":"Attention","text":""},{"location":"developer/#early-version-data-structure-improvements","title":"Early Version Data Structure Improvements","text":"<p>In the initial versions of MolTopolParser, all data classes inherit directly from <code>pydantic.BaseModel</code>.  This implementation did not utilize templated data classes for each hierarchical level,  leading to some redundancy that could be streamlined to enhance the package's efficiency and maintainability.  If you encounter issues or have suggestions for improvements, please do not hesitate to submit an issue request or contribute directly by implementing enhancements.</p>"},{"location":"developer/#api-documentation","title":"API Documentation","text":"<p>As of now, comprehensive API documentation has not been established for MolTopolParser. For users requiring documentation of specific data formats,  it is advised to create a markdown file, such as <code>xxx_yyy.md</code>, detailing the data structure and its usage.  Place this file in the <code>docs/reference</code> directory. To update the documentation site with this new information,  add an entry to the <code>mkdocs.yml</code> file under the <code>Reference</code> section and use the <code>mkdocs serve</code>  command to generate and view the documentation locally.</p> <p>Example modification in <code>mkdocs.yml</code> file:</p> <p><pre><code>nav:\n  - Getting Started: index.md\n  - Concepts: concepts.md\n  - Developer's Guide: developer.md\n  - Reference:\n      - gmx.MolTop: reference/gmx.MolTop.md\n      - Name_eg_xxx.yyy: reference/xxx_yyy.md #&lt;------ here \n</code></pre> Run the following command to render the documentation:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"developer/#need-help","title":"Need Help?","text":"<p>If you encounter any problems or have questions while contributing, please open an issue on the GitHub repository.</p>"},{"location":"install/","title":"Install","text":"<p>Installation is as simple as:</p> <pre><code>pip install moltopolparser\n</code></pre> <p>MolTopolParser has a few dependencies:</p> <ul> <li>pydantic</li> <li>numpy</li> </ul>"},{"location":"reference/gmx.MolTop/","title":"gmx.MolTop","text":"<ul> <li> <p>represents a molecular topology </p> </li> <li> <p>source from gromacs mannul </p> </li> </ul> <pre><code>[ moleculetype ]\n; name  nrexcl\nUrea         3\n\n[ atoms ]\n;   nr    type   resnr  residu    atom    cgnr  charge\n     1       C       1    UREA      C1       1   0.683\n     2       O       1    UREA      O2       1  -0.683\n     3      NT       1    UREA      N3       2  -0.622\n     4       H       1    UREA      H4       2   0.346\n     5       H       1    UREA      H5       2   0.276\n     6      NT       1    UREA      N6       3  -0.622\n     7       H       1    UREA      H7       3   0.346\n     8       H       1    UREA      H8       3   0.276\n\n[ bonds ]\n;  ai    aj funct           c0           c1\n    3     4     1 1.000000e-01 3.744680e+05\n    3     5     1 1.000000e-01 3.744680e+05\n    6     7     1 1.000000e-01 3.744680e+05\n    6     8     1 1.000000e-01 3.744680e+05\n    1     2     1 1.230000e-01 5.020800e+05\n    1     3     1 1.330000e-01 3.765600e+05\n    1     6     1 1.330000e-01 3.765600e+05\n\n[ pairs ]\n;  ai    aj funct           c0           c1\n    2     4     1 0.000000e+00 0.000000e+00\n    2     5     1 0.000000e+00 0.000000e+00\n    2     7     1 0.000000e+00 0.000000e+00\n    2     8     1 0.000000e+00 0.000000e+00\n    3     7     1 0.000000e+00 0.000000e+00\n    3     8     1 0.000000e+00 0.000000e+00\n    4     6     1 0.000000e+00 0.000000e+00\n    5     6     1 0.000000e+00 0.000000e+00\n\n[ angles ]\n;  ai    aj    ak funct           c0           c1\n    1     3     4     1 1.200000e+02 2.928800e+02\n    1     3     5     1 1.200000e+02 2.928800e+02\n    4     3     5     1 1.200000e+02 3.347200e+02\n    1     6     7     1 1.200000e+02 2.928800e+02\n    1     6     8     1 1.200000e+02 2.928800e+02\n    7     6     8     1 1.200000e+02 3.347200e+02\n    2     1     3     1 1.215000e+02 5.020800e+02\n    2     1     6     1 1.215000e+02 5.020800e+02\n    3     1     6     1 1.170000e+02 5.020800e+02\n\n[ dihedrals ]\n;  ai    aj    ak    al funct           c0           c1           c2\n    2     1     3     4     1 1.800000e+02 3.347200e+01 2.000000e+00\n    6     1     3     4     1 1.800000e+02 3.347200e+01 2.000000e+00\n    2     1     3     5     1 1.800000e+02 3.347200e+01 2.000000e+00\n    6     1     3     5     1 1.800000e+02 3.347200e+01 2.000000e+00\n    2     1     6     7     1 1.800000e+02 3.347200e+01 2.000000e+00\n    3     1     6     7     1 1.800000e+02 3.347200e+01 2.000000e+00\n    2     1     6     8     1 1.800000e+02 3.347200e+01 2.000000e+00\n    3     1     6     8     1 1.800000e+02 3.347200e+01 2.000000e+00\n\n[ dihedrals ]\n;  ai    aj    ak    al funct           c0           c1\n    3     4     5     1     2 0.000000e+00 1.673600e+02\n    6     7     8     1     2 0.000000e+00 1.673600e+02\n    1     3     6     2     2 0.000000e+00 1.673600e+02\n</code></pre>"}]}